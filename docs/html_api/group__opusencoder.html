<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Opus: Opus Encoder</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Opus&#160;<span id="projectnumber">0.9.6-157-g363924e</span></div>
   <div id="projectbrief">IETFlow-delayaudiocodec</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Opus Encoder</div>  </div>
</div>
<div class="contents">

<p>Since Opus is a stateful codec, the encoding process starts with creating an encoder state.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opus encoder state.  <a href="#gaf461a3ef2f10c2fe8b994a176f06c9bd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opusencoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18">opus_encoder_get_size</a> (int channels)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opusencoder.html#gaa89264fd93c9da70362a0c9b96b9ca88">opus_encoder_create</a> (<a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> Fs, int channels, int application, int *error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes an encoder state.  <a href="#gaa89264fd93c9da70362a0c9b96b9ca88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opusencoder.html#ga515db1c267a7421dacaad3610f79eb79">opus_encoder_init</a> (<a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *st, <a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> Fs, int channels, int application)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a previously allocated encoder state The memory pointed to by st must be the size returned by opus_encoder_get_size.  <a href="#ga515db1c267a7421dacaad3610f79eb79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opusencoder.html#ga88621a963b809ebfc27887f13518c966">opus_encode</a> (<a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *st, const <a class="el" href="opus__types_8h.html#acc9ed7cf60479eb81f9648c6ec27dc26">opus_int16</a> *pcm, int frame_size, unsigned char *data, int max_data_bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes an Opus frame.  <a href="#ga88621a963b809ebfc27887f13518c966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opusencoder.html#gace941e4ef26ed844879fde342ffbe546">opus_encode_float</a> (<a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *st, const float *pcm, int frame_size, unsigned char *data, int max_data_bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes an Opus frame from floating point input.  <a href="#gace941e4ef26ed844879fde342ffbe546"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opusencoder.html#ga5f4c05b4b51cdffec5a55dbf17bbfa1c">opus_encoder_destroy</a> (<a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *st)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an OpusEncoder allocated by opus_encoder_create.  <a href="#ga5f4c05b4b51cdffec5a55dbf17bbfa1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opusencoder.html#ga164cbb0425238961919adf1db67949df">opus_encoder_ctl</a> (<a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *st, int request,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a CTL function on an Opus encoder.  <a href="#ga164cbb0425238961919adf1db67949df"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Since Opus is a stateful codec, the encoding process starts with creating an encoder state. </p>
<p>This can be done with:</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span>          error;
 <a class="code" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd" title="Opus encoder state.">OpusEncoder</a> *enc;
 enc = <a class="code" href="group__opusencoder.html#gaa89264fd93c9da70362a0c9b96b9ca88" title="Allocates and initializes an encoder state.">opus_encoder_create</a>(Fs, channels, application, &amp;error);
</pre></div><p>where </p>
<ul>
<li>
Fs is the sampling rate and must be 8000, 12000, 16000, 24000, or 48000 </li>
<li>
channels is the number of channels (1 or 2) </li>
<li>
application is either OPUS_APPLICATION_VOIP or OPUS_APPLICATION_AUDIO </li>
<li>
error will hold the error code in case or failure (or OPUS_OK on success) </li>
<li>
the return value is a newly created encoder state to be used for encoding </li>
</ul>
<p>While <a class="el" href="group__opusencoder.html#gaa89264fd93c9da70362a0c9b96b9ca88" title="Allocates and initializes an encoder state.">opus_encoder_create()</a> allocates memory for the state, it's also possible to initialize pre-allocated memory:</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span>          size;
 <span class="keywordtype">int</span>          error;
 <a class="code" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd" title="Opus encoder state.">OpusEncoder</a> *enc;
 size = <a class="code" href="group__opusencoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18">opus_encoder_get_size</a>(channels);
 enc = malloc(size);
 error = <a class="code" href="group__opusencoder.html#ga515db1c267a7421dacaad3610f79eb79" title="Initializes a previously allocated encoder state The memory pointed to by st must be the size returne...">opus_encoder_init</a>(enc, Fs, channels, application);
</pre></div><p>where <a class="el" href="group__opusencoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18">opus_encoder_get_size()</a> returns the required size for the encoder state. Note that future versions of this code may change the size, so no assuptions should be made about it.</p>
<p>The encoder state is always continuous in memory and only a shallow copy is sufficient to copy it (e.g. memcpy())</p>
<p>It is possible to change some of the encoder's settings using the <a class="el" href="group__opusencoder.html#ga164cbb0425238961919adf1db67949df" title="Perform a CTL function on an Opus encoder.">opus_encoder_ctl()</a> interface. All these settings already default to the recommended value, so they should only be changed when necessary. The most common settings one may want to change are:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__opusencoder.html#ga164cbb0425238961919adf1db67949df" title="Perform a CTL function on an Opus encoder.">opus_encoder_ctl</a>(enc, <a class="code" href="group__encoderctls.html#ga0bb51947e355b33d0cb358463b5101a7" title="Configures the bitrate in the encoder.">OPUS_SET_BITRATE</a>(bitrate));
 <a class="code" href="group__opusencoder.html#ga164cbb0425238961919adf1db67949df" title="Perform a CTL function on an Opus encoder.">opus_encoder_ctl</a>(enc, <a class="code" href="group__encoderctls.html#ga3483877bf1687a75dd4a1de6f85f291c" title="Configures the encoder&#39;s computational complexity.">OPUS_SET_COMPLEXITY</a>(complexity));
 <a class="code" href="group__opusencoder.html#ga164cbb0425238961919adf1db67949df" title="Perform a CTL function on an Opus encoder.">opus_encoder_ctl</a>(enc, <a class="code" href="group__encoderctls.html#gaaa87ccee4ae46aa6c9528e03c5122b89" title="Configures the type of signal being encoded.">OPUS_SET_SIGNAL</a>(signal_type));
</pre></div><p>where </p>
<ul>
<li>
bitrate is in bits per second (b/s) </li>
<li>
complexity is a value from 1 to 10 where 1 is the lowest complexity and 10 is the highest </li>
<li>
signal_type is either OPUS_AUTO (default), OPUS_SIGNAL_VOICE, or OPUS_SIGNAL_MUSIC </li>
</ul>
<p>See <a class="el" href="group__encoderctls.html">Encoder related CTLs</a> and <a class="el" href="group__genericctls.html">Generic CTLs</a> for a complete list of parameters that can be set or queried. Most parameters can be set or changed at any time during a stream.</p>
<p>To encode a frame, <a class="el" href="group__opusencoder.html#ga88621a963b809ebfc27887f13518c966" title="Encodes an Opus frame.">opus_encode()</a> or <a class="el" href="group__opusencoder.html#gace941e4ef26ed844879fde342ffbe546" title="Encodes an Opus frame from floating point input.">opus_encode_float()</a> must be called with exactly one frame (2.5, 5, 10, 20, 40 or 60 ms) of audio data: </p>
<div class="fragment"><pre class="fragment"> len = <a class="code" href="group__opusencoder.html#ga88621a963b809ebfc27887f13518c966" title="Encodes an Opus frame.">opus_encode</a>(enc, audio_frame, frame_size, packet, max_packet);
</pre></div><p>where </p>
<ul>
<li>
audio_frame is the audio data in opus_int16 (or float for <a class="el" href="group__opusencoder.html#gace941e4ef26ed844879fde342ffbe546" title="Encodes an Opus frame from floating point input.">opus_encode_float()</a>) </li>
<li>
frame_size is the duration of the frame in samples (per channel) </li>
<li>
packet is the byte array to which the compressed data is written </li>
<li>
max_packet is the maximum number of bytes that can be written in the packet (1276 bytes is recommended) </li>
</ul>
<p><a class="el" href="group__opusencoder.html#ga88621a963b809ebfc27887f13518c966" title="Encodes an Opus frame.">opus_encode()</a> and opus_encode_frame() return the number of bytes actually written to the packet. If that value is negative, then an error has occured. If the value is 1, then the packet does not need to be transmitted (DTX)</p>
<p>Once the encoder state if no longer needed, it can be destroyed with</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__opusencoder.html#ga5f4c05b4b51cdffec5a55dbf17bbfa1c" title="Frees an OpusEncoder allocated by opus_encoder_create.">opus_encoder_destroy</a>(enc);
</pre></div><p>If the encoder was created with <a class="el" href="group__opusencoder.html#ga515db1c267a7421dacaad3610f79eb79" title="Initializes a previously allocated encoder state The memory pointed to by st must be the size returne...">opus_encoder_init()</a> rather than <a class="el" href="group__opusencoder.html#gaa89264fd93c9da70362a0c9b96b9ca88" title="Allocates and initializes an encoder state.">opus_encoder_create()</a>, then no action is required aside from potentially freeing the memory that was manually allocated for it (calling free(enc) for the example above) </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaf461a3ef2f10c2fe8b994a176f06c9bd"></a><!-- doxytag: member="opus.h::OpusEncoder" ref="gaf461a3ef2f10c2fe8b994a176f06c9bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> <a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opus encoder state. </p>
<p>This contains the complete state of an Opus encoder. It is position independent and can be freely copied. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__opusencoder.html#gaa89264fd93c9da70362a0c9b96b9ca88" title="Allocates and initializes an encoder state.">opus_encoder_create</a>,<a class="el" href="group__opusencoder.html#ga515db1c267a7421dacaad3610f79eb79" title="Initializes a previously allocated encoder state The memory pointed to by st must be the size returne...">opus_encoder_init</a> </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga88621a963b809ebfc27887f13518c966"></a><!-- doxytag: member="opus.h::opus_encode" ref="ga88621a963b809ebfc27887f13518c966" args="(OpusEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, int max_data_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="opus__types_8h.html#acc9ed7cf60479eb81f9648c6ec27dc26">opus_int16</a> *&#160;</td>
          <td class="paramname"><em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_data_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encodes an Opus frame. </p>
<p>The passed frame_size must an opus frame size for the encoder's sampling rate. For example, at 48kHz the permitted values are 120, 240, 480, or 960. Passing in a duration of less than 10ms (480 samples at 48kHz) will prevent the encoder from using the LPC or hybrid modes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td><code>OpusEncoder*</code>: Encoder state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcm</td><td><code>opus_int16*</code>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_size</td><td><code>int</code>: Number of samples per frame of input signal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td><code>char*</code>: Output payload (at least max_data_bytes long) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_data_bytes</td><td><code>int</code>: Allocated memory for payload; don't use for controlling bitrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of the data payload (in bytes) </dd></dl>

</div>
</div>
<a class="anchor" id="gace941e4ef26ed844879fde342ffbe546"></a><!-- doxytag: member="opus.h::opus_encode_float" ref="gace941e4ef26ed844879fde342ffbe546" args="(OpusEncoder *st, const float *pcm, int frame_size, unsigned char *data, int max_data_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_encode_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frame_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_data_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encodes an Opus frame from floating point input. </p>
<p>The passed frame_size must an opus frame size for the encoder's sampling rate. For example, at 48kHz the permitted values are 120, 240, 480, or 960. Passing in a duration of less than 10ms (480 samples at 48kHz) will prevent the encoder from using the LPC or hybrid modes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td><code>OpusEncoder*</code>: Encoder state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcm</td><td><code>float*</code>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(float) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_size</td><td><code>int</code>: Number of samples per frame of input signal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td><code>char*</code>: Output payload (at least max_data_bytes long) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_data_bytes</td><td><code>int</code>: Allocated memory for payload; don't use for controlling bitrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>length of the data payload (in bytes) </dd></dl>

</div>
</div>
<a class="anchor" id="gaa89264fd93c9da70362a0c9b96b9ca88"></a><!-- doxytag: member="opus.h::opus_encoder_create" ref="gaa89264fd93c9da70362a0c9b96b9ca88" args="(opus_int32 Fs, int channels, int application, int *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a>* opus_encoder_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&#160;</td>
          <td class="paramname"><em>Fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>application</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an encoder state. </p>
<p>There are three coding modes: OPUS_APPLICATION_VOIP gives best quality at a given bitrate for voice signals. It enhances the input signal by high-pass filtering and emphasizing formants and harmonics. Optionally it includes in-band forward error correction to protect against packet loss. Use this mode for typical VoIP applications. Because of the enhancement, even at high bitrates the output may sound different from the input. OPUS_APPLICATION_AUDIO gives best quality at a given bitrate for most non-voice signals like music. Use this mode for music and mixed (music/voice) content, broadcast, and applications requiring less than 15 ms of coding delay. OPUS_APPLICATION_RESTRICTED_LOWDELAY configures low-delay mode that disables the speech-optimized mode in exchange for slightly reduced delay. This is useful when the caller knows that the speech-optimized modes will not be needed (use with caution). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Fs</td><td><code>opus_int32</code>: Sampling rate of input signal (Hz) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channels</td><td><code>int</code>: Number of channels (1/2) in input signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">application</td><td><code>int</code>: Coding mode (OPUS_APPLICATION_VOIP/OPUS_APPLICATION_AUDIO/OPUS_APPLICATION_RESTRICTED_LOWDELAY) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td><code>int*</code>: Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga164cbb0425238961919adf1db67949df"></a><!-- doxytag: member="opus.h::opus_encoder_ctl" ref="ga164cbb0425238961919adf1db67949df" args="(OpusEncoder *st, int request,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_encoder_ctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a CTL function on an Opus encoder. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__encoderctls.html">Encoder related CTLs</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f4c05b4b51cdffec5a55dbf17bbfa1c"></a><!-- doxytag: member="opus.h::opus_encoder_destroy" ref="ga5f4c05b4b51cdffec5a55dbf17bbfa1c" args="(OpusEncoder *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opus_encoder_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees an OpusEncoder allocated by opus_encoder_create. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td><code>OpusEncoder*</code>: State to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaefeb7dc1d6e3b59dea5ea674c86e9c18"></a><!-- doxytag: member="opus.h::opus_encoder_get_size" ref="gaefeb7dc1d6e3b59dea5ea674c86e9c18" args="(int channels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_encoder_get_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga515db1c267a7421dacaad3610f79eb79"></a><!-- doxytag: member="opus.h::opus_encoder_init" ref="ga515db1c267a7421dacaad3610f79eb79" args="(OpusEncoder *st, opus_int32 Fs, int channels, int application)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_encoder_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opusencoder.html#gaf461a3ef2f10c2fe8b994a176f06c9bd">OpusEncoder</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&#160;</td>
          <td class="paramname"><em>Fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>application</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes a previously allocated encoder state The memory pointed to by st must be the size returned by opus_encoder_get_size. </p>
<p>This is intended for applications which use their own allocator instead of malloc. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__opusencoder.html#gaa89264fd93c9da70362a0c9b96b9ca88" title="Allocates and initializes an encoder state.">opus_encoder_create</a>,<a class="el" href="group__opusencoder.html#gaefeb7dc1d6e3b59dea5ea674c86e9c18">opus_encoder_get_size</a> To reset a previously initialized state use the <a class="el" href="group__genericctls.html#gadc74e4fa8bcdf9994187d52d92207337" title="Resets the codec state to be equivalent to a freshly initialized state.">OPUS_RESET_STATE</a> CTL. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">st</td><td><code>OpusEncoder*</code>: Encoder state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fs</td><td><code>opus_int32</code>: Sampling rate of input signal (Hz) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channels</td><td><code>int</code>: Number of channels (1/2) in input signal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">application</td><td><code>int</code>: Coding mode (OPUS_APPLICATION_VOIP/OPUS_APPLICATION_AUDIO/OPUS_APPLICATION_RESTRICTED_LOWDELAY) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">OPUS_OK</td><td>Success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu Sep 22 2011 17:58:07 for Opus by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
